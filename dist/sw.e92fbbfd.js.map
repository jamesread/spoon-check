{"mappings":"AEAO,IAAI,EAAW,EAAE,CDIxB,eAAe,IACb,IAAM,EAAQ,MAAM,OAAO,IAAI,CCJZ,GDMnB,OAAM,EAAM,MAAM,CAAC,EACrB,CAGA,eAAe,IACb,IAAM,EAAO,MAAM,OAAO,IAAI,EAE9B,OAAM,QAAQ,GAAG,CACf,EAAK,GAAG,CAAC,AAAA,GAAK,ACdG,KDcH,GAAiB,OAAO,MAAM,CAAC,IAEjD,CAKA,eAAe,EAAS,CAAK,EAEvB,EAAM,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,QAAQ,CAAC,MAAM,GACnD,EAAM,WAAW,CACf,OAAO,KAAK,CAAC,EAAM,OAAO,EAAE,IAAI,CAAC,AAAA,GAC/B,AAAI,GAIG,OAAO,IAAI,CA7BV,WA6BoB,IAAI,CAAC,AAAA,GACxB,MAAM,EAAM,OAAO,EAAE,IAAI,CAAC,AAAA,GAExB,EAAM,GAAG,CAAC,EAAM,OAAO,CAAE,EAAS,KAAK,IAAI,IAAI,CAAC,IAC9C,MAOrB,CAEA,iBAAiB,UAAW,AAAA,GAAK,EAAE,SAAS,CAAC,MAC7C,iBAAiB,WAAY,AAAA,GAAK,EAAE,SAAS,CAAC,MAC9C,iBAAiB,QAAS,AAAA,GAAK,EAAE,SAAS,CAAC,EAAQ","sources":["<anon>","src/sw.js","node_modules/@parcel/service-worker/service-worker.js"],"sourcesContent":["var $9f6538ba86e4d72c$exports = {};\nlet $59e9af023252b064$export$e538f94cc8cf4db8 = [];\nlet $59e9af023252b064$export$83d89fbfd8236492 = \"\";\nfunction $59e9af023252b064$export$c208e1278d7beb2(m, v) {\n    $59e9af023252b064$export$e538f94cc8cf4db8 = m;\n    $59e9af023252b064$export$83d89fbfd8236492 = v;\n}\n\n\nconst $9f6538ba86e4d72c$var$RUNTIME = \"runtime\";\nasync function $9f6538ba86e4d72c$var$install() {\n    const cache = await caches.open((0, $59e9af023252b064$export$83d89fbfd8236492));\n    await cache.addAll((0, $59e9af023252b064$export$e538f94cc8cf4db8));\n}\n// The activate handler takes care of cleaning up old caches.\nasync function $9f6538ba86e4d72c$var$activate() {\n    const keys = await caches.keys();\n    await Promise.all(keys.map((k)=>k !== (0, $59e9af023252b064$export$83d89fbfd8236492) && caches.delete(k)));\n}\n// The fetch handler serves responses for same-origin resources from a cache.\n// If no response is found, it populates the runtime cache with the response\n// from the network before returning it to the page.\nasync function $9f6538ba86e4d72c$var$swFetch(event) {\n    // Skip cross-origin requests, like those for Google Analytics.\n    if (event.request.url.startsWith(self.location.origin)) event.respondWith(caches.match(event.request).then((cachedResponse)=>{\n        if (cachedResponse) return cachedResponse;\n        return caches.open($9f6538ba86e4d72c$var$RUNTIME).then((cache)=>{\n            return fetch(event.request).then((response)=>{\n                // Put a copy of the response in the runtime cache.\n                return cache.put(event.request, response.clone()).then(()=>{\n                    return response;\n                });\n            });\n        });\n    }));\n}\naddEventListener(\"install\", (e)=>e.waitUntil($9f6538ba86e4d72c$var$install()));\naddEventListener(\"activate\", (e)=>e.waitUntil($9f6538ba86e4d72c$var$activate()));\naddEventListener(\"fetch\", (e)=>e.waitUntil($9f6538ba86e4d72c$var$swFetch(e)));\n\n\n//# sourceMappingURL=sw.e92fbbfd.js.map\n","import { manifest, version } from '@parcel/service-worker'\n\nconst RUNTIME = 'runtime'\n\nasync function install () {\n  const cache = await caches.open(version)\n\n  await cache.addAll(manifest)\n}\n\n// The activate handler takes care of cleaning up old caches.\nasync function activate () {\n  const keys = await caches.keys()\n\n  await Promise.all(\n    keys.map(k => k !== version && caches.delete(k))\n  )\n}\n\n// The fetch handler serves responses for same-origin resources from a cache.\n// If no response is found, it populates the runtime cache with the response\n// from the network before returning it to the page.\nasync function swFetch (event) {\n  // Skip cross-origin requests, like those for Google Analytics.\n  if (event.request.url.startsWith(self.location.origin)) {\n    event.respondWith(\n      caches.match(event.request).then(cachedResponse => {\n        if (cachedResponse) {\n          return cachedResponse\n        }\n\n        return caches.open(RUNTIME).then(cache => {\n          return fetch(event.request).then(response => {\n            // Put a copy of the response in the runtime cache.\n            return cache.put(event.request, response.clone()).then(() => {\n              return response\n            })\n          })\n        })\n      })\n    )\n  }\n}\n\naddEventListener('install', e => e.waitUntil(install()))\naddEventListener('activate', e => e.waitUntil(activate()))\naddEventListener('fetch', e => e.waitUntil(swFetch(e)))\n","export let manifest = [];\nexport let version = '';\n\n// Called by the runtime.\nexport function _register(m, v) {\n  manifest = m;\n  version = v;\n}\n"],"names":["$59e9af023252b064$export$e538f94cc8cf4db8","$9f6538ba86e4d72c$var$install","cache","caches","open","addAll","$9f6538ba86e4d72c$var$activate","keys","Promise","all","map","k","delete","$9f6538ba86e4d72c$var$swFetch","event","request","url","startsWith","self","location","origin","respondWith","match","then","cachedResponse","fetch","response","put","clone","addEventListener","e","waitUntil"],"version":3,"file":"sw.e92fbbfd.js.map"}