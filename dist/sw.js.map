{"mappings":"kBACMA,EAAQ,cACRC,EAAO,UAGPC,EAAa,yGAUnBC,KAAKC,iBAAgB,WAAYC,IAC/BA,EAAMC,UACJC,OAAOC,KAAKR,GACTS,MAAKC,GAASA,EAAMC,OAAOT,KAC3BO,KAAKN,KAAKS,mBAKjBT,KAAKC,iBAAgB,YAAaC,UAC1BQ,EAAa,CAAIb,EAAUC,GACjCI,EAAMC,UACJC,OAAOO,OAAOL,MAAKM,GACVA,EAAWC,QAAOC,IAAcJ,EAAcK,SAASD,OAC7DR,MAAKU,GACCC,QAAQC,IAAIF,EAAeG,KAAIC,GAC7BhB,OAAOiB,OAAOD,QAEtBd,MAAI,IAAON,KAAKsB,QAAQC,cAO/BvB,KAAKC,iBAAgB,SAAUC,IAEzBA,EAAMsB,QAAQC,IAAIC,WAAW1B,KAAK2B,SAASC,SAC7C1B,EAAM2B,YACJzB,OAAO0B,MAAM5B,EAAMsB,SAASlB,MAAKyB,GAC3BA,GAIG3B,OAAOC,KAAKP,GAASQ,MAAKC,GACxByB,MAAM9B,EAAMsB,SAASlB,MAAK2B,GAExB1B,EAAM2B,IAAIhC,EAAMsB,QAASS,EAASE,SAAS7B,MAAI,IAC7C2B","sources":["src/sw.js"],"sourcesContent":["const VERSION = 2;\nconst PRECACHE = 'precache-v1';\nconst RUNTIME = 'runtime';\n\n// A list of local resources we always want to be cached.\nconst PRECACHE_URLS = [\n  'index.html',\n  './', // Alias for index.html\n  'icon.83aa3da3.png',\n  'main.1f19ae8e.js',\n  'main.af46ece4.css',\n  'spoon-check.webmanifest'\n];\n\n// The install handler takes care of precaching the resources we always need.\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(PRECACHE)\n      .then(cache => cache.addAll(PRECACHE_URLS))\n      .then(self.skipWaiting())\n  );\n});\n\n// The activate handler takes care of cleaning up old caches.\nself.addEventListener('activate', event => {\n  const currentCaches = [PRECACHE, RUNTIME];\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return cacheNames.filter(cacheName => !currentCaches.includes(cacheName));\n    }).then(cachesToDelete => {\n      return Promise.all(cachesToDelete.map(cacheToDelete => {\n        return caches.delete(cacheToDelete);\n      }));\n    }).then(() => self.clients.claim())\n  );\n});\n\n// The fetch handler serves responses for same-origin resources from a cache.\n// If no response is found, it populates the runtime cache with the response\n// from the network before returning it to the page.\nself.addEventListener('fetch', event => {\n  // Skip cross-origin requests, like those for Google Analytics.\n  if (event.request.url.startsWith(self.location.origin)) {\n    event.respondWith(\n      caches.match(event.request).then(cachedResponse => {\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n\n        return caches.open(RUNTIME).then(cache => {\n          return fetch(event.request).then(response => {\n            // Put a copy of the response in the runtime cache.\n            return cache.put(event.request, response.clone()).then(() => {\n              return response;\n            });\n          });\n        });\n      })\n    );\n  }\n});\n"],"names":["$d47028408e84e55c85ee0e77c05ac727$var$PRECACHE","$d47028408e84e55c85ee0e77c05ac727$var$RUNTIME","$d47028408e84e55c85ee0e77c05ac727$var$PRECACHE_URLS","self","addEventListener","event","waitUntil","caches","open","then","cache","addAll","skipWaiting","currentCaches","keys","cacheNames","filter","cacheName","includes","cachesToDelete","Promise","all","map","cacheToDelete","delete","clients","claim","request","url","startsWith","location","origin","respondWith","match","cachedResponse","fetch","response","put","clone"],"version":3,"file":"sw.js.map"}