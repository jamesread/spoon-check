{"version":3,"sources":["sw.js"],"names":["VERSION","PRECACHE","RUNTIME","PRECACHE_URLS","self","addEventListener","event","waitUntil","caches","open","then","cache","addAll","skipWaiting","currentCaches","keys","cacheNames","filter","cacheName","includes","cachesToDelete","Promise","all","map","cacheToDelete","delete","clients","claim","request","url","startsWith","location","origin","respondWith","match","cachedResponse","fetch","response","put","clone"],"mappings":";AAAA,IAAMA,EAAU,EACVC,EAAW,cACXC,EAAU,UAGVC,EAAgB,CACpB,aACA,KACA,oBACA,mBACA,oBACA,2BAIFC,KAAKC,iBAAiB,UAAW,SAAAC,GAC/BA,EAAMC,UACJC,OAAOC,KAAKR,GACTS,KAAK,SAAAC,GAASA,OAAAA,EAAMC,OAAOT,KAC3BO,KAAKN,KAAKS,kBAKjBT,KAAKC,iBAAiB,WAAY,SAAAC,GAC1BQ,IAAAA,EAAgB,CAACb,EAAUC,GACjCI,EAAMC,UACJC,OAAOO,OAAOL,KAAK,SAAAM,GACVA,OAAAA,EAAWC,OAAO,SAAAC,GAAa,OAACJ,EAAcK,SAASD,OAC7DR,KAAK,SAAAU,GACCC,OAAAA,QAAQC,IAAIF,EAAeG,IAAI,SAAAC,GAC7BhB,OAAAA,OAAOiB,OAAOD,QAEtBd,KAAK,WAAMN,OAAAA,KAAKsB,QAAQC,aAO/BvB,KAAKC,iBAAiB,QAAS,SAAAC,GAEzBA,EAAMsB,QAAQC,IAAIC,WAAW1B,KAAK2B,SAASC,SAC7C1B,EAAM2B,YACJzB,OAAO0B,MAAM5B,EAAMsB,SAASlB,KAAK,SAAAyB,GAC3BA,OAAAA,GAIG3B,OAAOC,KAAKP,GAASQ,KAAK,SAAAC,GACxByB,OAAAA,MAAM9B,EAAMsB,SAASlB,KAAK,SAAA2B,GAExB1B,OAAAA,EAAM2B,IAAIhC,EAAMsB,QAASS,EAASE,SAAS7B,KAAK,WAC9C2B,OAAAA","file":"sw.js","sourceRoot":"../src","sourcesContent":["const VERSION = 2;\nconst PRECACHE = 'precache-v1';\nconst RUNTIME = 'runtime';\n\n// A list of local resources we always want to be cached.\nconst PRECACHE_URLS = [\n  'index.html',\n  './', // Alias for index.html\n  'icon.83aa3da3.png',\n  'main.1f19ae8e.js',\n  'main.af46ece4.css',\n  'spoon-check.webmanifest'\n];\n\n// The install handler takes care of precaching the resources we always need.\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(PRECACHE)\n      .then(cache => cache.addAll(PRECACHE_URLS))\n      .then(self.skipWaiting())\n  );\n});\n\n// The activate handler takes care of cleaning up old caches.\nself.addEventListener('activate', event => {\n  const currentCaches = [PRECACHE, RUNTIME];\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return cacheNames.filter(cacheName => !currentCaches.includes(cacheName));\n    }).then(cachesToDelete => {\n      return Promise.all(cachesToDelete.map(cacheToDelete => {\n        return caches.delete(cacheToDelete);\n      }));\n    }).then(() => self.clients.claim())\n  );\n});\n\n// The fetch handler serves responses for same-origin resources from a cache.\n// If no response is found, it populates the runtime cache with the response\n// from the network before returning it to the page.\nself.addEventListener('fetch', event => {\n  // Skip cross-origin requests, like those for Google Analytics.\n  if (event.request.url.startsWith(self.location.origin)) {\n    event.respondWith(\n      caches.match(event.request).then(cachedResponse => {\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n\n        return caches.open(RUNTIME).then(cache => {\n          return fetch(event.request).then(response => {\n            // Put a copy of the response in the runtime cache.\n            return cache.put(event.request, response.clone()).then(() => {\n              return response;\n            });\n          });\n        });\n      })\n    );\n  }\n});\n"]}